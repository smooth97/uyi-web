{"version":3,"sources":["screen/Draggable.jsx","images/person_walking.png","screen/Canvas.jsx","App.js","index.js"],"names":["Draggable","children","onDragStart","onDragEnd","props","ref","useRef","useThree","raycaster","size","camera","useMemo","mouse2D","THREE","mouse3D","offset","normal","plane","bind","useGesture","onDrag","xy","x","y","nx","width","ny","height","set","setFromCamera","getWorldDirection","negate","setFromNormalAndCoplanarPoint","ray","intersectPlane","current","position","copy","add","event","eventObject","point","getWorldPosition","sub","Mesh","texture","viewport","scale","attach","args","map","ImageMesh","load","Person","Ground","onPointerDown","e","stopPropagation","rotation-x","Math","PI","Lighting","intensity","CanvasComp","useState","drag","setDrag","dragProps","OrbitControls","enabled","position-y","App","ReactDOM","render","document","getElementById"],"mappings":"6NAKO,SAASA,EAAT,GAAoE,IAA/CC,EAA8C,EAA9CA,SAAUC,EAAoC,EAApCA,YAAaC,EAAuB,EAAvBA,UAAcC,EAAS,sDAClEC,EAAMC,mBAD4D,EAEpCC,cAA5BC,EAFgE,EAEhEA,UAAWC,EAFqD,EAErDA,KAAMC,EAF+C,EAE/CA,OAF+C,EAGpBC,mBAAQ,WAC1D,MAAO,CACLC,QAAS,IAAIC,UACbC,QAAS,IAAID,UACbE,OAAQ,IAAIF,UACZG,OAAQ,IAAIH,UACZI,MAAO,IAAIJ,WAEZ,IARKD,EAHgE,EAGhEA,QAASE,EAHuD,EAGvDA,QAASC,EAH8C,EAG9CA,OAAQC,EAHsC,EAGtCA,OAAQC,EAH8B,EAG9BA,MASpCC,EAAOC,YAAW,CACtBC,OAAQ,YAAqB,IAAD,gBAAjBC,GAAiB,GAAZC,EAAY,KAATC,EAAS,KAEpBC,EAAMF,EAAIb,EAAKgB,MAAS,EAAI,EAC5BC,GAAOH,EAAId,EAAKkB,OAAU,EAAI,EAEpCf,EAAQgB,IAAIJ,EAAIE,GAGhBlB,EAAUqB,cAAcjB,EAASF,GAGjCA,EAAOoB,kBAAkBd,GAAQe,SAGjCd,EAAMe,8BAA8BhB,EAAQF,GAG5CN,EAAUyB,IAAIC,eAAejB,EAAOH,GAGpCT,EAAI8B,QAAQC,SAASC,KAAKvB,GAASwB,IAAIvB,IAEzCb,YAAa,YAAgB,IAAbqC,EAAY,EAAZA,MACNC,EAAuBD,EAAvBC,YAAaC,EAAUF,EAAVE,MAGrBD,EAAYE,iBAAiB3B,GAAQ4B,IAAIF,GAGzC3B,EAAQuB,KAAKI,GAGbvC,EAAYqC,IAEdpC,UAAW,gBAAGoC,EAAH,EAAGA,MAAH,OAAepC,EAAUoC,MAEtC,OACE,2DAAOlC,IAAKA,GAASa,KAAYd,GAAjC,aACGH,KCxDQ,UAA0B,2CCOnC2C,EAAO,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAERpC,EADeF,cAAbuC,SACcrB,MAAQ,EAE9B,OACE,uBAAMsB,MAAO,CAACtC,EAAMA,EAAMA,GAA1B,UACE,qCAAqBuC,OAAO,WAAWC,KAAM,CAAC,EAAG,EAAG,KACpD,mCAAmBD,OAAO,WAAWE,IAAKL,QAKhD,SAASM,IACP,IAEMN,GAAU,IAAIhC,iBAAsBuC,KAAKC,GAE/C,OAAO,cAAC,EAAD,CAAMR,QAASA,IAGxB,SAASS,EAAOlD,GAAQ,IAEhBK,EADeF,cAAbuC,SACcrB,MAGtB,OACE,+CAAM8B,cAFc,SAACC,GAAD,OAAOA,EAAEC,mBAEOC,cAAaC,KAAKC,GAAK,GAAOxD,GAAlE,cACE,qCAAqB6C,KAAM,CAACxC,EAAMA,KAClC,6CAKN,SAASoD,IACP,OACE,qCACE,8BAAcC,UAAW,KACzB,4BAAY1B,SAAU,CAAC,EAAG,EAAG,QAKpB,SAAS2B,IAAa,MAEXC,oBAAS,GAFE,mBAE5BC,EAF4B,KAEtBC,EAFsB,KAG7BC,EAAY,CAChBjE,YAAa,kBAAMgE,GAAQ,IAC3B/D,UAAW,kBAAM+D,GAAQ,KAG3B,OACE,eAAC,IAAD,CAAQxD,OAAQ,CAAE0B,SAAU,CAAC,EAAG,EAAG,IAAnC,UACE,uBAAOY,OAAO,aAAaC,KAAM,CAAC,WAClC,cAACmB,EAAA,EAAD,CAAeC,SAAUJ,IACzB,cAACX,EAAD,CAAQgB,cAAa,KACrB,cAACT,EAAD,IACA,cAAC7D,EAAD,2BAAemE,GAAf,aACE,cAAChB,EAAD,UClDOoB,MAVf,WACE,OACE,mCAGE,cAACR,EAAD,OCLNS,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,W","file":"static/js/main.c57aac72.chunk.js","sourcesContent":["import React, { useMemo, useRef } from \"react\";\nimport { useThree } from \"react-three-fiber\";\nimport { useGesture } from \"react-use-gesture\";\nimport * as THREE from \"three\";\n\nexport function Draggable({ children, onDragStart, onDragEnd, ...props }) {\n  const ref = useRef();\n  const { raycaster, size, camera } = useThree();\n  const { mouse2D, mouse3D, offset, normal, plane } = useMemo(() => {\n    return {\n      mouse2D: new THREE.Vector2(), // Normalized 2D screen space mouse coords\n      mouse3D: new THREE.Vector3(), // 3D world space mouse coords\n      offset: new THREE.Vector3(), // Drag point offset from object origin\n      normal: new THREE.Vector3(), // Normal of the drag plane\n      plane: new THREE.Plane(), // Drag plane\n    };\n  }, []);\n  const bind = useGesture({\n    onDrag: ({ xy: [x, y] }) => {\n      // Compute normalized mouse coordinates (screen space)\n      const nx = (x / size.width) * 2 - 1;\n      const ny = (-y / size.height) * 2 + 1;\n      // Unlike the mouse from useThree, this works offscreen\n      mouse2D.set(nx, ny);\n\n      // Update raycaster (otherwise it doesn't track offscreen)\n      raycaster.setFromCamera(mouse2D, camera);\n\n      // The drag plane is normal to the camera view\n      camera.getWorldDirection(normal).negate();\n\n      // Find the plane that's normal to the camera and contains our drag point\n      plane.setFromNormalAndCoplanarPoint(normal, mouse3D);\n\n      // Find the point of intersection\n      raycaster.ray.intersectPlane(plane, mouse3D);\n\n      // Update the object position with the original offset\n      ref.current.position.copy(mouse3D).add(offset);\n    },\n    onDragStart: ({ event }) => {\n      const { eventObject, point } = event;\n\n      // Save the offset of click point from object origin\n      eventObject.getWorldPosition(offset).sub(point);\n\n      // Set initial 3D cursor position (needed for onDrag plane calculation)\n      mouse3D.copy(point);\n\n      // Run user callback\n      onDragStart(event);\n    },\n    onDragEnd: ({ event }) => onDragEnd(event),\n  });\n  return (\n    <group ref={ref} {...bind()} {...props}>\n      {children}\n    </group>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/person_walking.466245d0.png\";","import React, { useState, useMemo } from \"react\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { OrbitControls } from \"@react-three/drei\";\nimport { Draggable } from \"./Draggable\";\nimport * as THREE from \"three\";\nimport Person from \"../images/person_walking.png\";\n\nconst Mesh = ({ texture }) => {\n  const { viewport } = useThree();\n  const size = viewport.width / 5;\n\n  return (\n    <mesh scale={[size, size, size]}>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2, 2]} />\n      <meshBasicMaterial attach=\"material\" map={texture} />\n    </mesh>\n  );\n};\n\nfunction ImageMesh() {\n  const url =\n    \"https://uyi-images.s3.amazonaws.com/dev/cybertron.cg.tu-berlin.de/person_walking1.png\";\n  const texture = new THREE.TextureLoader().load(Person);\n  // const texture = useMemo(() => new THREE.TextureLoader().load(url), [url]);\n  return <Mesh texture={texture} />;\n}\n\nfunction Ground(props) {\n  const { viewport } = useThree();\n  const size = viewport.width;\n\n  const onPointerDown = (e) => e.stopPropagation();\n  return (\n    <mesh onPointerDown={onPointerDown} rotation-x={-Math.PI / 2} {...props}>\n      <planeBufferGeometry args={[size, size]} />\n      <meshStandardMaterial />\n    </mesh>\n  );\n}\n\nfunction Lighting() {\n  return (\n    <>\n      <ambientLight intensity={0.3} />\n      <pointLight position={[2, 2, 2]} />\n    </>\n  );\n}\n\nexport default function CanvasComp() {\n  // drag\n  const [drag, setDrag] = useState(false);\n  const dragProps = {\n    onDragStart: () => setDrag(true),\n    onDragEnd: () => setDrag(false),\n  };\n\n  return (\n    <Canvas camera={{ position: [0, 2, 4] }}>\n      <color attach=\"background\" args={[\"black\"]} />\n      <OrbitControls enabled={!drag} />\n      <Ground position-y={-0.5} />\n      <Lighting />\n      <Draggable {...dragProps}>\n        <ImageMesh />\n      </Draggable>\n    </Canvas>\n  );\n}\n","import React from \"react\";\nimport \"./styles.css\";\nimport CanvasComp from \"./screen/Canvas\";\n\nfunction App() {\n  return (\n    <>\n      {/* <ImageMesh /> */}\n      {/* <CanvasContainer /> */}\n      <CanvasComp />\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}